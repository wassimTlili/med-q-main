generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  student
  maintainer
  admin
}

// Type of user-submitted report (French slugs)
enum ReportType {
  erreur_de_saisie      // Erreur de saisie
  question_hors_cours   // Question hors cours
  correction_erronee    // Correction erronée
}

model User {
  id                    String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                 String         @unique(map: "profiles_email_idx")
  role                  Role           @default(student)
  createdAt             DateTime       @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt             DateTime       @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  password              String?
  name                  String?
  image                 String?
  google_id             String?        @unique(map: "profiles_google_id_idx")
  facebook_id           String?        @unique(map: "profiles_facebook_id_idx")
  emailVerified         DateTime?      @map("email_verified")
  passwordResetExpires  DateTime?      @map("password_reset_expires")
  passwordResetToken    String?        @map("password_reset_token")
  status                String         @default("pending")
  verificationToken     String?        @map("verification_token")
  passwordUpdatedAt     DateTime?      @map("password_updated_at") @db.Timestamptz(6)
  sexe                  String?
  niveauId              String?        @map("niveau_id") @db.Uuid
  semesterId            String?        @map("semester_id") @db.Uuid
  profileCompleted      Boolean        @default(false) @map("profile_completed")
  hasActiveSubscription Boolean        @default(false) @map("has_active_subscription")
  subscriptionExpiresAt DateTime?      @map("subscription_expires_at") @db.Timestamptz(6)
  niveau                Niveau?        @relation(fields: [niveauId], references: [id])
  semester              Semester?      @relation(fields: [semesterId], references: [id])
  reports               Report[]
  progress              UserProgress[]
  courseGroups          CourseGroup[]
  pinnedSpecialties     PinnedSpecialty[]
  pinnedQuestions       PinnedQuestion[]
  comments              Comment[]
  notifications         Notification[]
  questionUserData      QuestionUserData[]
  questionComments      QuestionComment[]
  commentLikes          CommentLike[]
  activities            UserActivity[]
  // Added reverse relations for session corrections
  sessionCorrections            SessionCorrection[]
  sessionCorrectionSubmissions  SessionCorrectionSubmission[]

  @@map("profiles")
}

model Specialty {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String
  description String?
  icon        String?
  iconType    String?   @map("icon_type")
  iconColor   String?   @map("icon_color")
  imageUrl    String?   @map("image_url")
  niveauId    String?   @map("niveau_id") @db.Uuid
  semesterId  String?   @map("semester_id") @db.Uuid
  isFree      Boolean   @default(false) @map("is_free")
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  lectures    Lecture[]
  niveau      Niveau?   @relation(fields: [niveauId], references: [id])
  semester    Semester? @relation(fields: [semesterId], references: [id])
  courseGroups CourseGroup[]
  pinnedSpecialties PinnedSpecialty[]
  sessions    Session[]

  // Separate media for the course reminder section
  courseReminderMediaUrl  String? @map("course_reminder_media_url")
  courseReminderMediaType String? @map("course_reminder_media_type")
  @@map("specialties")
}
model Lecture {
  id          String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  specialtyId String         @map("specialty_id") @db.Uuid
  title       String
  description String?
  isFree      Boolean        @default(false) @map("is_free")
  createdAt   DateTime       @default(now()) @map("created_at") @db.Timestamptz(6)
  specialty   Specialty      @relation(fields: [specialtyId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  questions   Question[]
  reports     Report[]
  progress    UserProgress[]
  lectureGroups LectureGroup[]
  comments    Comment[]

  @@index([specialtyId], map: "idx_lectures_specialty")
  @@map("lectures")
}

model CourseGroup {
  id           String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name         String
  specialtyId  String         @map("specialty_id") @db.Uuid
  createdBy    String         @map("created_by") @db.Uuid
  createdAt    DateTime       @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime       @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  specialty    Specialty      @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  creator      User           @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  lectureGroups LectureGroup[]

  @@unique([specialtyId, name], map: "unique_specialty_group_name")
  @@map("course_groups")
}

model LectureGroup {
  id            String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  lectureId     String      @map("lecture_id") @db.Uuid
  courseGroupId String      @map("course_group_id") @db.Uuid
  createdAt     DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)
  lecture       Lecture     @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  courseGroup   CourseGroup @relation(fields: [courseGroupId], references: [id], onDelete: Cascade)

  @@unique([lectureId, courseGroupId], map: "unique_lecture_group")
  @@map("lecture_groups")
}

model PinnedSpecialty {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  specialtyId String    @map("specialty_id") @db.Uuid
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  specialty   Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@unique([userId, specialtyId], map: "unique_user_specialty_pin")
  @@map("pinned_specialties")
}

model PinnedQuestion {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  questionId String   @map("question_id") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId], map: "unique_user_question_pin")
  @@map("pinned_questions")
}

model Comment {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  lectureId String   @map("lecture_id") @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  content   String
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  // New fields for anonymity & threaded replies
  isAnonymous     Boolean  @default(false) @map("is_anonymous")
  parentCommentId String?  @map("parent_comment_id") @db.Uuid
  lecture   Lecture  @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent    Comment? @relation("CommentToComment", fields: [parentCommentId], references: [id])
  replies   Comment[] @relation("CommentToComment")
  likes     CommentLike[]

  @@index([lectureId], map: "idx_comments_lecture")
  @@index([parentCommentId], map: "idx_comments_parent")
  @@map("comments")
}

// Track comment likes (hearts)
model CommentLike {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  commentId String   @map("comment_id") @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId], map: "unique_comment_like")
  @@index([userId], map: "idx_comment_likes_user")
  @@map("comment_likes")
}

model Notification {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  title     String
  message   String
  type      String   @default("info") // info, success, warning, error
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead], map: "idx_notifications_user_read")
  @@map("notifications")
}

model Question {
  id                 String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  lectureId          String   @map("lecture_id") @db.Uuid
  type               String
  text               String
  options            Json?
  correctAnswers     String[] @map("correct_answers")
  explanation        String?
  hidden             Boolean  @default(false)
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  courseReminder     String?  @map("course_reminder")
  number             Int?
  session            String?
  mediaUrl           String?  @map("media_url")
  mediaType          String?  @map("media_type")
  courseReminderMediaUrl  String? @map("course_reminder_media_url")
  courseReminderMediaType String? @map("course_reminder_media_type")
  caseNumber         Int?     @map("case_number")
  caseText           String?  @map("case_text")
  caseQuestionNumber Int?     @map("case_question_number")
  parentQuestionId   String?  @map("parent_question_id") @db.Uuid
  lecture            Lecture  @relation(fields: [lectureId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  parent             Question? @relation("QuestionToQuestion", fields: [parentQuestionId], references: [id])
  children           Question[] @relation("QuestionToQuestion")
  reports            Report[]
  pinnedQuestions    PinnedQuestion[]
  userData           QuestionUserData[]
  questionComments   QuestionComment[]
  optionStats        QuestionOptionStat[]

  @@index([number], map: "idx_questions_number")
  @@index([caseNumber, caseQuestionNumber], map: "idx_questions_case")
  @@index([parentQuestionId], map: "idx_questions_parent")
  @@map("questions")
}

model QuestionUserData {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  questionId  String   @map("question_id") @db.Uuid
  notes       String?
  // Personal note image attachments (stored as uploaded URLs or small data URIs)
  notesImageUrls String[] @map("notes_image_urls") @default([])
  highlights  Json?
  attempts    Int      @default(0)
  lastScore   Float?
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId], map: "unique_user_question_data")
  @@index([userId], map: "idx_question_user_data_user")
  @@index([questionId], map: "idx_question_user_data_question")
  @@map("question_user_data")
}

model QuestionComment {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  questionId String   @map("question_id") @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  content    String
  isAnonymous Boolean @default(false) @map("is_anonymous")
  // Image attachments (uploaded via UploadThing) – store direct URLs
  imageUrls  String[] @map("image_urls") @default([])
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentCommentId String? @map("parent_comment_id") @db.Uuid
  parent    QuestionComment? @relation("QuestionCommentToQuestionComment", fields: [parentCommentId], references: [id])
  replies   QuestionComment[] @relation("QuestionCommentToQuestionComment")

  @@index([questionId], map: "idx_question_comments_question")
  @@index([userId], map: "idx_question_comments_user")
  @@index([parentCommentId], map: "idx_question_comments_parent")
  @@map("question_comments")
}

// Aggregated statistics for MCQ option selections and total submissions.
// optionId NULL row stores total submissions for the question.
model QuestionOptionStat {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  questionId String   @map("question_id") @db.Uuid
  optionKey  String   @map("option_key") // 'TOTAL' row stores aggregate submissions
  count      Int      @default(0)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([questionId, optionKey], map: "unique_question_option_key")
  @@index([questionId], map: "idx_question_option_stats_question")
  @@map("question_option_stats")
}

model UserProgress {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  lectureId    String   @map("lecture_id") @db.Uuid
  questionId   String?  @map("question_id") @db.Uuid
  // Optional image attachments for personal notes (not shared)
  notesImageUrls String[] @map("notes_image_urls") @default([])
  completed    Boolean  @default(false)
  score        Float?
  lastAccessed DateTime @default(now()) @map("last_accessed") @db.Timestamptz(6)
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  lecture      Lecture  @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, lectureId, questionId], map: "unique_user_lecture_question")
  @@index([userId, questionId], map: "idx_user_progress_user_question")
  @@index([userId, lectureId], map: "idx_user_progress_user_lecture")
  @@map("user_progress")
}

// Generic user activity events (e.g., question attempts) for lightweight daily counting
model UserActivity {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  type      String   @default("question_attempt")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt], map: "idx_user_activity_user_date")
  @@map("user_activity")
}

model Report {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  questionId String   @map("question_id") @db.Uuid
  lectureId  String   @map("lecture_id") @db.Uuid
  message    String?  // now optional to allow type-only reports
  userId     String?  @map("user_id") @db.Uuid
  status     String   @default("pending")
  // New field: report type (mapped to DB column "type")
  reportType ReportType @default(erreur_de_saisie) @map("type")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  lecture    Lecture  @relation(fields: [lectureId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  question   Question @relation(fields: [questionId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user       User?    @relation(fields: [userId], references: [id])

  @@map("reports")
}

model Niveau {
  id        String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String      @unique
  order     Int         @unique
  createdAt DateTime    @default(now()) @map("created_at") @db.Timestamptz(6)
  users     User[]
  Specialty Specialty[]
  semesters Semester[]
  sessions  Session[]

  @@map("niveaux")
}

model Semester {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String
  order     Int
  niveauId  String    @map("niveau_id") @db.Uuid
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  niveau    Niveau    @relation(fields: [niveauId], references: [id])
  specialties Specialty[]
  sessions   Session[]
  users      User[]

  @@unique([niveauId, order], map: "unique_niveau_semester_order")
  @@map("semesters")
}

model Session {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name           String
  niveauId       String?  @map("niveau_id") @db.Uuid
  semesterId     String?  @map("semester_id") @db.Uuid
  specialtyId    String?  @map("specialty_id") @db.Uuid
  pdfUrl         String?  @map("pdf_url")
  correctionUrl  String?  @map("correction_url")
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  niveau         Niveau?  @relation(fields: [niveauId], references: [id])
  semester       Semester? @relation(fields: [semesterId], references: [id])
  specialty      Specialty? @relation(fields: [specialtyId], references: [id])
  // Relations added for structured correction zone
  correction     SessionCorrection?
  correctionSubmissions SessionCorrectionSubmission[]

  @@map("sessions")
}

// Structured correction zone for a session (official reference created by maintainer/admin)
model SessionCorrection {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId  String   @map("session_id") @db.Uuid
  data       Json     // { tables: [...], texts: [...] }
  createdBy  String   @map("created_by") @db.Uuid
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  session    Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  creator    User     @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@unique([sessionId], map: "unique_session_correction")
  @@map("session_corrections")
}

// User submission for a session correction zone (their filled answers)
model SessionCorrectionSubmission {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionId  String   @map("session_id") @db.Uuid
  userId     String   @map("user_id") @db.Uuid
  answers    Json     // mirrors structure of SessionCorrection.data
  score      Float?
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  session    Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId], map: "unique_session_user_correction_submission")
  @@map("session_correction_submissions")
}

// RAG indexing (DB-backed embeddings)
model RagIndex {
  id        String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String?
  createdAt DateTime   @default(now()) @map("created_at") @db.Timestamptz(6)
  chunks    RagChunk[]

  @@map("rag_index")
}

model RagChunk {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  indexId   String   @map("index_id") @db.Uuid
  page      Int?
  ord       Int?     @map("ord")
  text      String
  embedding Float[]
  meta      Json?
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  index     RagIndex @relation(fields: [indexId], references: [id], onDelete: Cascade)

  @@index([indexId], map: "idx_ragchunk_index")
  @@map("rag_chunks")
}
